#include <Stepper.h>
#include <Adafruit_LiquidCrystal.h>

#define STEPS 96
#define SPEED 500

Adafruit_LiquidCrystal lcd(0);

const int Trigger = 2;
const int Echo = 3;
Stepper stepper(STEPS,4,5,6,0);

//highs on centimeters
const double H1 = 14;//15.53
const double H2 = 30;
const double H3 = 43;//42.43

long time;
long distance =0;//long distance;

////////Infrareds
//Dec. Pines
int[] infrared_inputs = {2,3,4,5};
int[] infrared_leds = {12,13,14,15};
int index = 0;

//distance (between infrereds)
double partial_distance = 0.2;
//time
double[] partial_times = {0,0,0,0};
//Velocity
double[] partial_velocity = {0,0,0,0};
//Aceleration
double[] partial_aceleration = {0,0,0,0};

byte rows[4] = {13,12,11,10};
byte columns[4] = {9,8,7,1};
char opciones[4][4] = {
                  	    {'1','2','3','A'},
	                    {'4','5','6','B'},
    	                    {'7','8','9','C'},
        	            {'*','0','#','D'}
                      };
                      
Keypad teclado = Keypad(makeKeymap(opciones), rows, columns, 4, 4);
char boton;



void setupt(){
  Serial.begin(9600);
  
  pinMode(Trigger, OUTPUT);
  pinMode(Echo, INPUT);
  digitalWrite(Trigger, LOW);
  
  stepper.setSpeed(SPEED);  

  //1st
   pinMode(infrared_input[0], INPUT);
   pinMode(infrared_led[0], OUTPUT);
  //2nd
   pinMode(infrared_input[1], INPUT);
   pinMode(infrared_led[1], OUTPUT);
  //3rd
   pinMode(infrared_input[2], INPUT);
   pinMode(infrared_led[2], OUTPUT);
  //4th
   pinMode(infrared_input[3], INPUT);
   pinMode(infrared_led[3], OUTPUT);

   startScreen();
}

void loop(){
  boton = teclado.getKey();

  digitalWrite(Trigger, HIGH);
  delayMicroseconds(10);//Enviamos un pulso de 10us
  digitalWrite(Trigger, LOW);
  
  time = pulseIn(Echo, HIGH); //obtenemos el ancho del pulso (tiempo)
  distance = t/59;//Obtenemos distancia en cm

  infrareds_behavior();

  switch(boton){
    case '1':
      this.to15Degrees(((distance<H1)?1:-1));
      printReport(15);
    break;
    case '2':
      this.to25Degrees(((distance<H2)?1:-1));
      printReport(25);
    break;
    case '3':
      this.to45Degrees(((distance<H3)?1:-1));
      printReport(45);
    break;
    case 'D':
      //si tuviera que hacer un método para exportar, iría aquí...
      restart();
    break;
  }
} 
  
void to15Degrees(int dir){//dir = 1/-1
  this.toDegrees(dir, H1);
}

void to25Degrees(int dir){
  this.toDegrees(dir, H2);
}

void to45Degrees(int dir){
  this.toDegrees(dir, H3);
}


//It is ok, but you are going to change from
  sign, because if the current high is
  	- more than the needed - izq (negative numbers-bajar)
  	- less than needed - der (positive numbers-subir)
  It will be applied to the multiplier of the motor

void toDegrees(int dir, double high){//dir = 1/-1
  int pasos = 0; 
  int multiplier = 0;

  while(distance!= high){
  	motor(pasos);//and that is going to increase or reduce the high
  	pasos += (dir*STEPS*multiplier);
  	multiplier++;
  }
  stepper.step(96);
  //without delay, because of the ultrasonic sensor
}

void infrareds_behavior(){
   int input_value = digitalRead(infrared_input[index]);

   if(input_value == 1){
	partial_times[index] = toSecs(millis());
	partial_velocity[index] = getVelocity(partial_times[index]);
	partial_aceleration[index] = getAceleration(partial_times[index]);
	index++;
   }

   printReport();

   if(boton == 'D'){
	//si tuviera que hacer un método para exportar, iría aquí...
	restart();
   }
}

String void getPTimesList(){
	return ((String)partial_times[0] 
	  + ", " + (String)partial_times[1]
	  + ", " + (String)partial_times[2]
	  + ", " + (String)partial_times[3]);
}

double toSecs(int miliseconds){
	return (miliseconds * 0.001);
}

String void getVelocityList(){
	return ((String)partial_velocity[0] 
	  + ", " + (String)partial_velocity[1]
	  + ", " + (String)partial_velocity[2]
	  + ", " + (String)partial_velocity[3]);
}

int getVelocity(double time){
	return (distance/time);
}

String void getAcelerationList(){
	return ((String)partial_aceleration[0] 
	  + ", " + (String)partial_aceleration[1]
	  + ", " + (String)partial_aceleration[2]
	  + ", " + (String)partial_aceleration[3]);
}

int getAceleration(double time){
	return (2*distance/(time*time));
}

void startScreen(){
  lcd.clear();
  lcd.begin(16, 2);

  lcd.setCursor(0, 0);
  lcd.print("Galieos's experiment");
  lcd.setCursor(0, 1);
  lcd.print("S = 1/2*a*t^2");
  delay(350);
}

void printReport(int degrees){
  lcd.clear();
  lcd.begin(16, 2);

  lcd.setCursor(0, 0);
  lcd.print("REPORT" +"("+ (String)degrees+")");	
  lcd.setCursor(0, 1);
  lcd.print("Times: " + getPTimesList());	
  lcd.print("Velocity: " + getVelocityList());	
  lcd.print("Aceleration: " + getAcelerationList());
}

void restart(){
  lcd.clear();
  index = 0 ;
  partial_times[0];
  partial_times[1];
  partial_times[2];
  partial_times[3];
}

NOTES

//distance < H1. Pienso que debería ser != porque como pude ser mayor o menor,para redudcir condiciones
//de if((dir == 1 && distance < H1) || (dir == -1 && distance > H1))
